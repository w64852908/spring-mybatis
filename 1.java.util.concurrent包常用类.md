#java.util.concurrent包常用类
##1.Atomic类型的操作具有原子性的类
###1.1AtomicBoolean、AtomicInteger、AtomicLong等
　　这些类实例的一些方法时原子性的，即多个线程操作时，一次只会有一个线程在执行操作。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。   

###1.2 synchronized的实现
　　使用传统的synchronized关键字、基于阻塞的锁机制实现。

	class Counter {  
        
	    private int value;  
	  
	    public synchronized int getValue() {  
	        return value;  
	    }  
	  
	    public synchronized int increment() {  
	        return ++value;  
	    }  
	  
	    public synchronized int decrement() {  
	        return --value;  
	    }  
	}   
	
　　以上属于比较粗糙、粒度比较大的实现，Atomic的线程安全是基于硬件同步策略和CAS（compare and swap）实现的。
　　
####硬件同步策略
　　现在的处理器都支持多重处理，当然也包含多个处理器共享外围设备和内存，同时，加强了指令集以支持一些多处理的特殊需求。特别是几乎所有的处理器都可以将其他处理器阻塞以便更新共享变量。
　　
####Compare and swap（CAS）
　　每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。这个交换过程完全是原子的，在CPU上计算完结果后，都会对比内存的结果是否还是原先的值，若不是，则认为不能替换，因为变量是volatile类型所以最终写入的数据会被其他线程看到，所以一个线程修改成功后，其他线程就发现自己修改失败了。   
　　   
　　CAS的实现
　　
	class CasCounter {
	
	    private SimulateCAS count;
	
	    public CasCounter(int initialValue) {
	        this.count = new SimulateCAS(initialValue);
	    }
	
	    public int getValue() {
	        return count.getValue();
	    }
	
	    public int increment() {
	        int oldValue = count.getValue();
	        //如果swap返回值与oldValue值不一致，说明已经有别的线程进行过了increment操作，需要重新赋值oldValue。直到本线程成功执行swap操作
	        while (count.compareAndSwap(oldValue, oldValue + 1) != oldValue) {
	            oldValue = count.getValue();
	        }
	        return oldValue + 1;
	    }
	
	}
	
	class SimulateCAS {
	
	    private int value;
	
	    public SimulateCAS(int value) {
	        this.value = value;
	    }
	
	    public synchronized int getValue() {
	        return value;
	    }
	
	
	    /**
	     * 如果预期值和CAS当前值相等，则赋其新值。
	     *
	     * @return 返回CAS原有值
	     */
	    public synchronized int compareAndSwap(int expectedValue, int newValue) {
	        int oldValue = value;
	        if (value == expectedValue) {
	            value = newValue;
	        }
	        return oldValue;
	    }
	}
　　
##2.ReentrantLock
###2.1 与synchronized的区别   
　　ａ.synchronized由编译器去执行加锁和释放，只需要在代码块或者方法声明即可。ReentrantLock需要手动来加锁和释放(粒度更细)，一般把unlock放在finally执行以避免忘记手动释放锁导致死锁。   
　　b.synchronized是非公平锁，而ReentrantLock可以指定锁类型。公平锁会按照线程提交的顺序获取到锁，而非公平锁是随机唤醒线程来获取锁。
　　
###2.2 一些使用场景
ａ.如果任务已经在执行中，则不再执行　　
	
	ReentrantLock lock = new ReentrantLock();
	
	//如果获取锁失败会直接返回
	if(lock.tryLock()){
		try {
			//do something
		} finally {
		  lock.unlock();
		}
	}
   
b.如果任务已经在执行，则等待被执行
   
	ReentrantLock lock = new ReentrantLock();

	try {
		//如果获取不到锁，则会等待锁被释放
		lock.lock();
		//do something
	} finally {
		lock.unlock();
	}

c.如果任务已经在执行，则尝试等待一段时间，超时则放弃

	ReentrantLock lock = new ReentrantLock();
	
	//如果获取锁失败，
	try{
		if(lock.tryLock(5, TimeUnit.SECONDS)){
			try{
				//do something
			}finally{
				lock.unlock();
			}
		}
	}catch(InterruptedException e){
		
	}
d.配合Condition来实现线程间通信(生产者消费者模型)

　　在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。

　　Condition的强大之处在于它可以为多个线程间建立不同的Condition， 使用synchronized/wait()只有一个阻塞队列，notifyAll会唤起所有阻塞队列下的线程，而使用lock/condition，可以实现多个阻塞队列，signalAll只会唤起某个阻塞队列下的阻塞线程。

	ReentrantLock lock = new ReentrantLock();
	Condition notFull = lock.newCondition;
	Condition notEmpty = lock.newCondition;
	
	public void put() {
        lock.lock();
        try {
            while (container.size() == maxSize) {
                System.out.print(Thread.currentThread().getName() + ": wait \n");
                notFull.await();//阻塞生产线程
            }
            container.add(new Date());
            System.out.println(Thread.currentThread().getName() + ": put:" + container.size());
            Thread.sleep(1000);
            notEmpty.signalAll();//唤醒消费线程
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public void take() {
        lock.lock();
        try {
            while (container.size() == 0) {
                System.out.print(Thread.currentThread().getName() + ": wait \n");
                notEmpty.await();//阻塞生产线程
            }
            ((LinkedList<Date>) container).poll();
            System.out.println(Thread.currentThread().getName() + ": take:" + container.size());
            Thread.sleep(1000);
            notFull.signalAll();//唤醒消费线程
            notFull.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
##3.ArrayBlockingQueue
###3.1 ArrayBlockingQueue介绍
　　ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。线程安全是指其内部通过ReentrantLock实现了多线程对竞争资源的互斥访问，有界是指队列底层的数组是有界限的。