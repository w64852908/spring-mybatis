#java.util.concurrent包常用类
##1.Atomic类型的操作具有原子性的类
###1.1AtomicBoolean、AtomicInteger、AtomicLong等
　　这些类实例的一些方法是原子性的，即多个线程操作时，一次只会有一个线程在执行操作。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。   

###1.2 synchronized的实现
　　使用传统的synchronized关键字、基于阻塞的锁机制实现。

	class Counter {  
        
	    private int value;  
	  
	    public synchronized int getValue() {  
	        return value;  
	    }  
	  
	    public synchronized int increment() {  
	        return ++value;  
	    }  
	  
	    public synchronized int decrement() {  
	        return --value;  
	    }  
	}   
	
　　以上属于比较粗糙、粒度比较大的实现，Atomic的线程安全是基于硬件同步策略和CAS（compare and swap）实现的。
　　
####硬件同步策略
　　现在的处理器都支持多重处理，当然也包含多个处理器共享外围设备和内存，同时，加强了指令集以支持一些多处理的特殊需求。特别是几乎所有的处理器都可以将其他处理器阻塞以便更新共享变量。
　　
####Compare and swap（CAS）
　　每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。这个交换过程完全是原子的，在CPU上计算完结果后，都会对比内存的结果是否还是原先的值，若不是，则认为不能替换，因为变量是volatile类型所以最终写入的数据会被其他线程看到，所以一个线程修改成功后，其他线程就发现自己修改失败了。   
　　   
　　CAS的实现
　　

	class CasCounter {
	
	    private SimulateCAS count;
	
	    public CasCounter(int initialValue) {
	        this.count = new SimulateCAS(initialValue);
	    }
	
	    public int getValue() {
	        return count.getValue();
	    }
	
	    public int increment() {
	        int oldValue = count.getValue();
	        //如果swap返回值与oldValue值不一致，说明已经有别的线程进行过了increment操作，需要重新赋值oldValue。直到本线程成功执行swap操作
	        while (count.compareAndSwap(oldValue, oldValue + 1) != oldValue) {
	            oldValue = count.getValue();
	        }
	        return oldValue + 1;
	    }
	
	}
	
	class SimulateCAS {
	
	    private int value;
	
	    public SimulateCAS(int value) {
	        this.value = value;
	    }
	
	    public synchronized int getValue() {
	        return value;
	    }
	
	
	    /**
	     * 如果预期值和CAS当前值相等，则赋其新值。
	     *
	     * @return 返回CAS原有值
	     */
	    public synchronized int compareAndSwap(int expectedValue, int newValue) {
	        int oldValue = value;
	        if (value == expectedValue) {
	            value = newValue;
	        }
	        return oldValue;
	    }
	}　
　　Atomic类的CAS实际上是由JDK内部的Unsafe类提供的方法，该类提供了硬件级别的原子操作。Unsafe类的使用是受限的，其内部提供了很多直接操作内存的方法。并且java.util.concurrent.atomic包下的原子操作类都是基于CAS实现的。

	//获取内存地址偏移量
	public native long staticFieldOffset(Field paramField);
	//内存分配与释放等
	public native long allocateMemory(long paramLong);
	public native long reallocateMemory(long paramLong1, long paramLong2);
	public native void freeMemory(long paramLong);

##2.ReentrantLock
###2.1 与synchronized的区别   
　　ａ.synchronized由编译器去执行加锁和释放，只需要在代码块或者方法声明即可。ReentrantLock需要手动来加锁和释放(粒度更细)，一般把unlock放在finally执行以避免忘记手动释放锁导致死锁。   
　　b.synchronized是非公平锁，而ReentrantLock可以指定锁类型。公平锁会按照线程提交的顺序获取到锁，而非公平锁是随机唤醒线程来获取锁。
###2.2 一些使用场景
　　ａ.如果任务已经在执行中，则不再执行　　
	
	ReentrantLock lock = new ReentrantLock();
	
	//如果获取锁失败会直接返回
	if(lock.tryLock()){
		try {
			//do something
		} finally {
		  lock.unlock();
		}
	}
   
　　b.如果任务已经在执行，则等待被执行
   
	ReentrantLock lock = new ReentrantLock();

	try {
		//如果获取不到锁，则会等待锁被释放
		lock.lock();
		//do something
	} finally {
		lock.unlock();
	}

　　c.如果任务已经在执行，则尝试等待一段时间，超时则放弃

	ReentrantLock lock = new ReentrantLock();
	
	//如果获取锁失败，
	try{
		if(lock.tryLock(5, TimeUnit.SECONDS)){
			try{
				//do something
			}finally{
				lock.unlock();
			}
		}
	}catch(InterruptedException e){
		
	}

　　d.如果任务已经在执行，则进行可以被中断的等待（可中断加锁）

	ReentrantLock lock = new ReentrantLock();
	
	try{
		//如果有进程调用次线程的interrupt()方法，则会响应中断
		lock.lockInterruptibly();
		//do something	
	} catch (InterruptedException e) {
		e.printStackTrace();
	} finally {
		lock.unlock();
	}

　　f.配合Condition来实现线程间通信(生产者消费者模型、阻塞队列)

　　在Condition中，用await()替换wait()，用signal()替换notify()，用signalAll()替换notifyAll()，传统线程的通信方式，Condition都可以实现，这里注意，Condition是被绑定到Lock上的，要创建一个Lock的Condition必须用newCondition()方法。

　　Condition的强大之处在于它可以为多个线程间建立不同的Condition， 使用synchronized/wait()只有一个阻塞队列，notifyAll会唤起所有阻塞队列下的线程，而使用lock/condition，可以实现多个阻塞队列，signalAll只会唤起某个阻塞队列下的阻塞线程。

	ReentrantLock lock = new ReentrantLock();
	Condition notFull = lock.newCondition;
	Condition notEmpty = lock.newCondition;
	
	public void put() {
        lock.lock();
        try {
            while (container.size() == maxSize) {
                System.out.print(Thread.currentThread().getName() + ": wait \n");
                notFull.await();//阻塞生产线程
            }
            container.add(new Date());
            System.out.println(Thread.currentThread().getName() + ": put:" + container.size());
            Thread.sleep(1000);
            notEmpty.signalAll();//唤醒消费线程
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
    public void take() {
        lock.lock();
        try {
            while (container.size() == 0) {
                System.out.print(Thread.currentThread().getName() + ": wait \n");
                notEmpty.await();//阻塞生产线程
            }
            ((LinkedList<Date>) container).poll();
            System.out.println(Thread.currentThread().getName() + ": take:" + container.size());
            Thread.sleep(1000);
            notFull.signalAll();//唤醒消费线程
            notFull.signal();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
    
##3.ArrayBlockingQueue
###3.1 ArrayBlockingQueue介绍
　　ArrayBlockingQueue是数组实现的线程安全的有界的阻塞队列。线程安全是指其内部通过ReentrantLock实现了多线程对竞争资源的互斥访问，有界是指队列底层的数组是有界限的。
　　
###3.2 ArrayBlockingQueue部分源码

a.offer和put方法（poll和take方法类似）
	
	//把指定元素插入到队列中，如果队列已满则插入失败
    public boolean offer(E e) {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            if (count == items.length)
                return false;
            else {
                enqueue(e);
                return true;
            }
        } finally {
            lock.unlock();
        }
    }
    
    //把指定的元素插入到队列中，如果队列已满则等待指定时长，过后队列还是满的则抛弃元素
    public boolean offer(E e, long timeout, TimeUnit unit)
        throws InterruptedException {

        checkNotNull(e);
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length) {
                if (nanos <= 0)
                    return false;
                nanos = notFull.awaitNanos(nanos);
            }
            enqueue(e);
            return true;
        } finally {
            lock.unlock();
        }
    }
    
    //如果队列已满，阻塞直到有空闲能插入元素
    public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }
    
    //底层数组进行入队操作，修改入队出队元素下标，且满足队列不为空的条件，随机唤醒一个出队的线程
    private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        notEmpty.signal();
    }
    

　　可以看到ArrayBlockingQueue和上一节基于ReentrantLock、Condition实现的阻塞队列原理是一样的。
　　
##4.CountDownLatch
###CountDownLatch简介
　　如果说ReentrantLock是排他锁，那么CountDownLatch就是共享锁了。在多个任务共同执行但是需要一组任务同时返回的场景下可以用到。使用起来也很简单，需要三个步骤。  
　　1.初始化CountDownLatch，指定其计数器的大小  
　　2.初始化各个线程，在每个线程执行完各自任务之后调用其countDown()方法，即可让计数器-1  
　　3.在start所有线程之后，调用其await()方法，即可将进程阻塞，直到计数器归零（所有线程执行完毕）为止。
　　  
　　网关会员卡同步逻辑就用到了此类：
　　  
　　不管是排它锁还是共享锁，其底层都是依赖了AbstractQueuedSynchronized（AQS）。
　　

##5.CyclicBarrier

##6.DelayQueue