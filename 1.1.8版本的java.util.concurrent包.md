#java.util.concurrent包常用类
##1.Atomic类型的操作具有原子性的类
###1.1AtomicBoolean、AtomicInteger、AtomicLong等
####1.1.1 Atomic类
　　这些类实例的一些方法时原子性的，即多个线程操作时，一次只会有一个线程在执行操作。原子变量类相当于一种泛化的volatile变量，能够支持原子的和有条件的读-改-写操作。   

####1.1.2 synchronized的实现
　　使用传统的synchronized关键字、基于阻塞的锁机制实现。

	class Counter {  
        
	    private int value;  
	  
	    public synchronized int getValue() {  
	        return value;  
	    }  
	  
	    public synchronized int increment() {  
	        return ++value;  
	    }  
	  
	    public synchronized int decrement() {  
	        return --value;  
	    }  
	}   
	
　　以上属于比较粗糙、粒度比较大的实现，Atomic的线程安全是基于硬件同步策略和CAS（compare and swap）实现的：  
　　a.现在的处理器都支持多重处理，当然也包含多个处理器共享外围设备和内存，同时，加强了指令集以支持一些多处理的特殊需求。特别是几乎所有的处理器都可以将其他处理器阻塞以便更新共享变量。  
　　b.每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。这个交换过程完全是原子的，在CPU上计算完结果后，都会对比内存的结果是否还是原先的值，若不是，则认为不能替换，因为变量是volatile类型所以最终写入的数据会被其他线程看到，所以一个线程修改成功后，其他线程就发现自己修改失败了。
　　
##2.ReentrantLock
###2.1与synchronized的区别   
　　ａ.synchronized由编译器去执行加锁和释放，只需要在代码块或者方法声明即可。ReentrantLock需要手动来加锁和释放(粒度更细)，一般把unlock放在finally执行以避免忘记手动释放锁导致死锁。   
　　b.synchronized是非公平锁，而ReentrantLock可以指定锁类型。公平锁会按照线程提交的顺序获取到锁，而非公平锁是随机唤醒线程来获取锁。
　　
　　